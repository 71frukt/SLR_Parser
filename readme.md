# Tenpiler - тензорный компилятор

Это учебный проект 4-го семестра по реализации синтаксического анализатора простого "арифметического"языка алгоритмом "shift-reduce". Курс "Введение в тензорные компиляторы"

Автор:
-   Шелонин Арсений, Б01-411

## Зависимости

| Зависимость           | Минимальная версия    | Назначение                                    |
|-----------------------|-----------------------|-----------------------------------------------|
| **CMake**             | 3.12                  | Сборка проекта и зависимостей                 |
| **GCC / Clang**       | GCC 10 / Clang 11     | Компиляция C++20 кода                         |
| **FLeX**              | 2.6.4                 | Токенизация исходного кода                    |

### Установка зависимостей (Ubuntu/Debian)

#### 1. Системные зависимости
```zsh
sudo apt update
sudo apt install -y \
    build-essential \
    git \
    wget \
    snap
```

#### 2. CMake (version 4.2.3)

```zsh
sudo snap install cmake --classic
echo 'export PATH="/snap/bin:$PATH"' >> ~/.zshrc # или ~/.bashrc
source ~/.zshrc # или ~/.bashrc
```

#### 3. FLeX
```zsh
sudo apt install flex libfl-dev
```

## Сборка проекта

```zsh
git clone https://github.com/71frukt/SLR_Parser.git
cd SLR_Parser

cmake -B build -DCMAKE_BUILD_TYPE=Release # -DSANITIZE=ON включение санитайзеров
cmake --build build -j$(nproc)
```

## Запуск
```zsh
./build/slr_parser [OPTIONS]
```


|       OPTIONS                    |                            |
|----------------------------------|----------------------------|
| `-h`, `--help`                   |   Вывести помощь           |
| `-f`, `--source_file` \<FILE\>   | Задать имя входного файла  |


## Описание

Это учебный проект реализации парсинга язка с грамматикой, описанной ниже.

```bnf
Expr   -> Expr + Term   | Expr - Term   | Term
Term   -> Term * Factor | Term * Factor | Factor
Factor -> (Expr)        | ID            | Num
```

Правила лексики описываются в файле `source/src/lexer/lexer.l`.


## Основной алгоритм

В основе синтаксического анализатора лежит построение детерменированного конечного автомата (ДКА) на состояниях, в которых может оказаться компилятор в процессе анализа. Состояние состоит из множества **пунктов**.

**Пункт** - это продукция (правило грамматики) с отметкой текущей позиции разбора. Эта отметка показывает, какую часть правила мы уже прочитали, а какую еще ожидаем. 

Пусть задана продукция `A -> XYZ`, тогда пунктами этой продукции будут являться
```bnf
A -> • XYZ
A -> X • YZ
A -> XY • Z
A -> XYZ •
```

В процессе работы парсер не знает наверняка, какое именно правило сейчас сработает, поэтому одно состояние объединяет в себе все варианты развития событий, которые допустимы в данный момент времени.

Теперь наша задача построить полный граф конечного автомата с непересекающимися состояниями. Для этого сначала введем две функции работы над состояниями.

#### 1. Closure (Замыкание)
Эта функция "дополняет" состояние. Если в текущем состоянии мы ожидаем начала некоторого нетерминала, то мы автоматически должны ожидать и начало любого правила, которое этот нетерминал описывает.

#### 2. Goto (Переход)
Эта функция описывает переход из одного состояния в другое при чтении символа **Х** (терминала или нетерминала), который сути является ребром в графе автомата. Если **I** - состояние (множество пунктов), то `GoTo(I, X)` - замыкание множества всех пунктов, которые были образованы из **I** после чтения **X**.

#### Построение ДКА
* Сначала расширим грамматику, добавив новое правило `Start -> Expr`. Начальное состояние сформируем как `Closure({Start -> • Expr})` и поместим его в список состояний.
* Для каждого необработанного состояния **I** и каждого символа грамматики **X**, который встречается после точки в пунктах этого состояния:
    - вычисляем новое состояние **J** = `GOTO(I, X)`.
    - Если **J** не пусто и *(!) такого состояния ещё нет в списке*, то добавляем его, записав переход из **I** к **J** по символу **X**.

*(!) Гарантирует, что состояния автомата не будут пересекаться.*

Построенный автомат называется **LR(0)** (читаем символы слева направо, читаем грамматику снизу вверх, смотрим вперед на 0 токенов). Автомат говорит только о том, как переходить между состояниями. Мы трансформируем его в управляющую таблицу.

Построив граф, мы переходим к самому анализу. Теперь парсер работает как виртуальная машина, используя две структуры данных:

**Стек:** Хранит историю — номера состояний, через которые мы прошли.
**Инпут:** Поток токенов, которые мы читаем слева направо. Парсер видит только один текущий токен (**Lookahead**).

**Цель:** Читая токены и меняя состояния в стеке, "свернуть" весь входной текст обратно к стартовому символу грамматики.

#### Конфликт Shift / Reduce
В некоторых состояниях ДКА возникает неопределенность.
Допустим, парсер разбирает правило `Term -> Factor`. Автомат предлагает сделать свертку (**Reduce**). Но одновременно с этим, грамматика позволяет продолжить чтение, ожидая умножения `Term -> Term * Factor` (**Shift**).

Чтобы решить, сворачивать сейчас или читать дальше, парсер должен проанализировать следующий символ во входной ленте. Для этого вводятся два множества.

#### 1. First
`First(a)` - это множество терминалов, с которых начинаются строки, порождаемые **a**.

#### 2. Follow
`Follow(A)` - это множество таких терминалов, которые могут располагаться справа от **A**.

Если мы хотим свернуть правило `A -> ...`, мы смотрим на следующий символ в Input:
* Если этот символ входит в `Follow(A)`, значит, свертка возможна — мы делаем **Reduce**.
* Если нет — мы откладываем свертку и делаем **Shift**.

#### Таблица управления
Собрав все данные (Автомат + First + Follow), мы строим финальную таблицу, которая управляет работой парсера. Она представляет собой матрицу, где строки — это **состояния**, а столбцы — **символы** грамматики.

Таблица делится на две части:
1.  **ACTION**: Определяет действие парсера (Сдвиг, Свертка, Успех, Ошибка) в зависимости от текущего терминала на входе.
2.  **GOTO**: Определяет, в какое состояние перейти после выполнения свертки (для нетерминалов).

Алгоритм заполнения ячеек таблицы `T[State, Symbol]`:

* **Shift (sN):** Если в автомате есть ребро из состояния `I` в `J` по терминалу `a`, то `T[I, a] = Shift J`. Интуитивный смысл - перенос токена в стек и перейти в состояние J.
* **Reduce (rK):** Если в состоянии `I` есть пункт с точкой на конце (`A -> α •`), то для всех терминалов из множества `Follow(A)` ставим `Reduce K` (где K — номер правила). 
* **Goto (N):** Если в автомате есть переход по нетерминалу `A` в состояние `J`, то `T[I, A] = J`.
* **Accept:** Если состояние содержит `Start -> Expr •` и на входе конец файла `$`.
* **Error:** Пустая ячейка означает синтаксическую ошибку.